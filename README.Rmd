---
output:
  md_document:
    variant: markdown_github
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

# MultCal2Sim

The goal of MultCal2Sim is to perform calibration with the pre-computed estimates. MultCal2Sim will calibrate initial estimates from the first data source onto reference control-totals from the second data source. There are two choices of computation tools available, post-stratification and raking....

## Installation

You can install MultCal2Sim from github with:

```{r gh-installation, eval = FALSE}
# install.packages('devtools')
#library(devtools)
devtools::install_github("statsccpr/MultCal2Sim")

```

## Example

This is a basic example which shows you how to solve a common problem. We will use `survey::api`, a dataset providing infomation about student performance in California Schools.

```{r api}

library(survey)
data(api,package = 'survey')

form_outcome = ~enroll
form_poststrat = ~sch.wide+both
```

###Step 0: Computing the estimate totals

The Data Source 1 is `apistrat`, which is a sample (pre) stratified by type of school (Elementary/Middle/High School), and the Data Source 2 is `apiclus1`, which is a cluster sample of school districts.Our goal is to estimate 

`est_tot_from_des_joint(form_additive,design_refer)`: estimate joint totals from a survey design project
`est_tot_from_des_1marg(form_1_term_only,design_refer)`: estimate one marginal totals from a survey design project


```{r step0_compute_est}

# stratified sample via ?apistrat
des_targ  = svydesign(id=~1,strata=~stype, weights=~pw, data=apistrat, fpc=~fpc)

# # one-stage cluster sample via ?apiclus1
des_2be_cal = svydesign(id=~dnum, weights=~pw, data=apiclus1, fpc=~fpc)

# helper function to compute estimated totals within joint strata
library(MultCal2Sim)
df_targ_tot_joint = est_tot_from_des_joint(form_additive=form_poststrat,
                                            design_refer=des_targ)
```

```{r prepared_form}
df_targ_tot_joint
form_poststrat
form_outcome
des_targ
des_2be_cal
```

###Step 1: Simulating draws of the estimated strata control totals from the referenced data source

m=1,2,3,...,M draws are simulated for each strata s=1,2,3,...,S in the first step.It will return one simulation of either joint totals or marginal totals in a data frame.

The `sim_tot_from_est()` function will simulate totals from pre-existing estimates.

```{r step1}
#simulate one draw
sim_tot_from_est(df_or_list_est_tot=df_targ_tot_joint,type_strata='joint',lgl_rej_neg_sim=TRUE)

# simulate 10 draws for joint totals
list_sim_out_joint = lapply(1:10,FUN=sim_tot_from_est,df_or_list_est_tot=df_targ_tot_joint,type_strata='joint')

# 10 draws
str(list_sim_out_joint,1)

# first draw
list_sim_out_joint[[1]]
```

###Step 2: Calibrating the estimates from the first data source onto the simulated control totals

We will pick a computation tool post-stratification or raking to calibrate the initial estimate to each draw we get in the step 1. It will return to multiple intermediate estimates. Here we will use post-stratification as our tool.

The function `cal_2_sim()` will calibrate (poststratify or rake) an outcome onto simulted poststrata totals.

```{r step2}

#using mcsp to calibrate the estimate to the first draw
cal_2_sim(des_2be_cal=des_2be_cal,
         df_or_list_sim=list_sim_out_joint[[1]],
         form_outcome=form_outcome,form_poststrat=form_poststrat,
         type_cal='mcsp')

# repeat the task 10 times
list_cal_out_joint = lapply(list_sim_out_joint,FUN=cal_2_sim,
                      des_2be_cal=des_2be_cal,
                      form_outcome=form_outcome,
                      form_poststrat=form_poststrat,
                      type_cal='mcsp')

str(list_cal_out_joint)
```

###Step 3: Computing the final point estimate and the standard error

The final point estimate is the average of intermediate calibrations, and the standard error will be returned as well.

The `combine_est` function will combine intermediate calibrated estimates

```{r step3}
# combine estimates
combine_est(list_cal_out_joint)

```


### Using Raking on marginal totals (MCSR)

```{r raking example}

# marginal targets
args(est_tot_from_des_1marg)
form_poststrat

# expect error if more than 1 RHS term in formula
form_poststrat

#est_tot_from_des_1marg(form_1_term_only=~sch.wide + both,design_refer=des_targ)

is.list(form_poststrat)

list_form_marg = list(~sch.wide,~both)
is.list(list_form_marg)

list_targ_tot_marg = lapply(list_form_marg,FUN=est_tot_from_des_1marg, design_refer=des_targ)



args(sim_tot_from_est)

# simulate one draw of margin(s)
sim_tot_from_est(df_or_list_est_tot=list_targ_tot_marg,type_strata='marginal',lgl_rej_neg_sim=TRUE)

# simulate 10 draws
list_sim_out_marg = lapply(1:10,FUN=sim_tot_from_est,df_or_list_est_tot=list_targ_tot_marg,type_strata='marginal')

# list of draws 10
str(list_sim_out_marg,2)

# 5th draw
list_sim_out_marg[[5]]

# use mcsr to compute intermediate estimates
list_cal_out_marg = lapply(list_sim_out_marg,FUN=cal_2_sim,
                            des_2be_cal=des_2be_cal,
                            form_outcome=form_outcome,
                            form_poststrat=list_form_marg,
                            type_cal='mcsr')

#step 3: combine the estimates and compute final uncertainty
combine_est(list_cal_out_marg)
```

# Overall MCS helper that wraps together steps 1-3

```{r}

mcs(des_2be_cal=des_2be_cal,
    df_or_list_est_tot=list_targ_tot_marg,
    form_outcome=form_outcome,
    form_poststrat=list_form_marg,
    type_cal='mcsr',
    num_sim=50,
    lgl_rej_neg_sim=TRUE)


```

`?mcs` has a parallel option

```{r,eval=FALSE}

# parallel
mcs(des_2be_cal=des_2be_cal,
    df_or_list_est_tot=list_targ_tot_marg,
    form_outcome=form_outcome,
    form_poststrat=list_form_marg,
    type_cal='mcsr',
    num_sim=50,
    parallel = TRUE,
    num_core = 4,
    lgl_rej_neg_sim=TRUE)

# mcs(des_2be_cal=des_2be_cal,
#     df_or_list_est_tot=df_targ_tot_joint,
#     form_outcome=form_outcome,
#     form_poststrat=form_poststrat,
#     type_cal='mcsp',
#     num_sim=200,
#     parallel = TRUE,
#     num_core = 4,
#     lgl_rej_neg_sim=TRUE)


```

